class LFSR():

	def __init__(self, seed, precision):
		self.seed = seed
		self.precision  = precision

	@staticmethod
	def int_to_bin(int_value, precision):
		bin_str = bin(int_value)[2:]
		if len(bin_str)<precision:
			appender = ''.join(['0']*(precision-len(bin_str)))
			return appender + bin_str
		else:
			return bin_str

	def lfsr_generator(self, taps):
		'''
		Generate the random number values for the LFSR
		:param taps: The tuple input presenting the tap bits in the input
		:return None: A geneerator function for generating the LFSR values
		'''
		# Converting the input seed value to the required binary string
		begin_val = self.int_to_bin(self.seed,self.precision)
		while 1:
			# Iterate through all the taps
			for index in range(len(taps) - 1):
				# Base condition
				if index == 0:
					xor = int(begin_val[taps[index] - 1]) ^ int(begin_val[taps[index + 1] - 1])
				# The condition for performing the chained xor
				else:
					xor = xor_prev ^ int(begin_val[taps[index + 1]])
				xor_prev = xor
			# Updating the lfsr value
			begin_val = str(xor) + begin_val[:-1]
			yield begin_val

lfsr = LFSR(100, 8)
for index, val in enumerate(lfsr.lfsr_generator((8,7,6,1))):
	integer_val = int(val,2)
	print (f'{val,integer_val} is the number generated by the LFSR for the given {index}')
	if index==10:
		break

