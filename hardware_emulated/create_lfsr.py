def lfsr(seed, steps):
	initial_val = seed
	xor = 0
	for _ in range(10):
		for step in steps:
			xor += int(initial_val[step-1])
		xor = 0 if xor%2==0 else 1
		initial_val, xor = str(xor) + initial_val[:-1], 0
		# print (initial_val, "The new updated value from the lfsr")
		yield initial_val
		if initial_val==seed:
			break

# lfsr('11001001', (8,7,6,1))


def int_to_bin(int_value):
	return bin(int_value)[2:]


def my_lfsr(init_seed, taps):
	begin_val = init_seed
	while 1:
		for index in  range(len(taps)-1):
			if index==0:
				xor = int(begin_val[taps[index]-1])^int(begin_val[taps[index+1]-1])
			else:
				xor = xor_prev^int(begin_val[taps[index+1]])
			xor_prev = xor
		begin_val = str(xor)+begin_val[:-1]
		yield begin_val


	# for index, tap in enumerate(taps):
	# 	xor = int(begin_val[tap-1])^int(begin_val[taps[index+1]])
	#

my_lfsr('10011001', (8,7,6,1))
for index, val in enumerate(my_lfsr('10011001', (8,7,6,1))):
	integer_val = int(val,2)
	print (f'{val,integer_val} is the number generated by the LFSR for the given {index}')
	if index==10:
		break